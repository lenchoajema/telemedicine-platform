{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport { EventTarget, Event, defineEventAttribute } from 'event-target-shim';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport { addListener, removeListener } from \"./EventEmitter\";\nimport Logger from \"./Logger\";\nimport MediaStream from \"./MediaStream\";\nimport MediaStreamTrack from \"./MediaStreamTrack\";\nimport MediaStreamTrackEvent from \"./MediaStreamTrackEvent\";\nimport RTCDataChannel from \"./RTCDataChannel\";\nimport RTCDataChannelEvent from \"./RTCDataChannelEvent\";\nimport RTCIceCandidate from \"./RTCIceCandidate\";\nimport RTCIceCandidateEvent from \"./RTCIceCandidateEvent\";\nimport RTCRtpReceiveParameters from \"./RTCRtpReceiveParameters\";\nimport RTCRtpReceiver from \"./RTCRtpReceiver\";\nimport RTCRtpSendParameters from \"./RTCRtpSendParameters\";\nimport RTCRtpSender from \"./RTCRtpSender\";\nimport RTCRtpTransceiver from \"./RTCRtpTransceiver\";\nimport RTCSessionDescription from \"./RTCSessionDescription\";\nimport RTCTrackEvent from \"./RTCTrackEvent\";\nimport * as RTCUtil from \"./RTCUtil\";\nvar log = new Logger('pc');\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar nextPeerConnectionId = 0;\nvar RTCPeerConnection = function (_EventTarget) {\n  function RTCPeerConnection(configuration) {\n    var _this;\n    _classCallCheck(this, RTCPeerConnection);\n    _this = _callSuper(this, RTCPeerConnection);\n    _this.localDescription = null;\n    _this.remoteDescription = null;\n    _this.signalingState = 'stable';\n    _this.iceGatheringState = 'new';\n    _this.connectionState = 'new';\n    _this.iceConnectionState = 'new';\n    _this._pcId = nextPeerConnectionId++;\n    if (!WebRTCModule.peerConnectionInit(configuration, _this._pcId)) {\n      throw new Error('Failed to initialize PeerConnection, check the native logs!');\n    }\n    _this._transceivers = [];\n    _this._remoteStreams = new Map();\n    _this._pendingTrackEvents = [];\n    _this._registerEvents();\n    log.debug(`${_this._pcId} ctor`);\n    return _this;\n  }\n  _inherits(RTCPeerConnection, _EventTarget);\n  return _createClass(RTCPeerConnection, [{\n    key: \"createOffer\",\n    value: function () {\n      var _createOffer = _asyncToGenerator(function* (options) {\n        var _this2 = this;\n        log.debug(`${this._pcId} createOffer`);\n        var _yield$WebRTCModule$p = yield WebRTCModule.peerConnectionCreateOffer(this._pcId, RTCUtil.normalizeOfferOptions(options)),\n          sdpInfo = _yield$WebRTCModule$p.sdpInfo,\n          newTransceivers = _yield$WebRTCModule$p.newTransceivers,\n          transceiversInfo = _yield$WebRTCModule$p.transceiversInfo;\n        log.debug(`${this._pcId} createOffer OK`);\n        newTransceivers === null || newTransceivers === void 0 ? void 0 : newTransceivers.forEach(function (t) {\n          var transceiverOrder = t.transceiverOrder,\n            transceiver = t.transceiver;\n          var newSender = new RTCRtpSender(_objectSpread(_objectSpread({}, transceiver.sender), {}, {\n            track: null\n          }));\n          var remoteTrack = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n          var newReceiver = new RTCRtpReceiver(_objectSpread(_objectSpread({}, transceiver.receiver), {}, {\n            track: remoteTrack\n          }));\n          var newTransceiver = new RTCRtpTransceiver(_objectSpread(_objectSpread({}, transceiver), {}, {\n            sender: newSender,\n            receiver: newReceiver\n          }));\n          _this2._insertTransceiverSorted(transceiverOrder, newTransceiver);\n        });\n        this._updateTransceivers(transceiversInfo);\n        return sdpInfo;\n      });\n      function createOffer(_x) {\n        return _createOffer.apply(this, arguments);\n      }\n      return createOffer;\n    }()\n  }, {\n    key: \"createAnswer\",\n    value: function () {\n      var _createAnswer = _asyncToGenerator(function* () {\n        log.debug(`${this._pcId} createAnswer`);\n        var _yield$WebRTCModule$p2 = yield WebRTCModule.peerConnectionCreateAnswer(this._pcId, {}),\n          sdpInfo = _yield$WebRTCModule$p2.sdpInfo,\n          transceiversInfo = _yield$WebRTCModule$p2.transceiversInfo;\n        this._updateTransceivers(transceiversInfo);\n        return sdpInfo;\n      });\n      function createAnswer() {\n        return _createAnswer.apply(this, arguments);\n      }\n      return createAnswer;\n    }()\n  }, {\n    key: \"setConfiguration\",\n    value: function setConfiguration(configuration) {\n      WebRTCModule.peerConnectionSetConfiguration(configuration, this._pcId);\n    }\n  }, {\n    key: \"setLocalDescription\",\n    value: function () {\n      var _setLocalDescription = _asyncToGenerator(function* (sessionDescription) {\n        var _desc;\n        log.debug(`${this._pcId} setLocalDescription`);\n        var desc;\n        if (sessionDescription) {\n          var _sessionDescription$s;\n          desc = {\n            type: sessionDescription.type,\n            sdp: (_sessionDescription$s = sessionDescription.sdp) != null ? _sessionDescription$s : ''\n          };\n          if (!RTCUtil.isSdpTypeValid(desc.type)) {\n            throw new Error(`Invalid session description: invalid type: ${desc.type}`);\n          }\n        } else {\n          desc = null;\n        }\n        var _yield$WebRTCModule$p3 = yield WebRTCModule.peerConnectionSetLocalDescription(this._pcId, desc),\n          sdpInfo = _yield$WebRTCModule$p3.sdpInfo,\n          transceiversInfo = _yield$WebRTCModule$p3.transceiversInfo;\n        if (sdpInfo.type && sdpInfo.sdp) {\n          this.localDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n          this.localDescription = null;\n        }\n        this._updateTransceivers(transceiversInfo, ((_desc = desc) === null || _desc === void 0 ? void 0 : _desc.type) === 'answer');\n        log.debug(`${this._pcId} setLocalDescription OK`);\n      });\n      function setLocalDescription(_x2) {\n        return _setLocalDescription.apply(this, arguments);\n      }\n      return setLocalDescription;\n    }()\n  }, {\n    key: \"setRemoteDescription\",\n    value: function () {\n      var _setRemoteDescription = _asyncToGenerator(function* (sessionDescription) {\n        var _sessionDescription$s2,\n          _desc$type,\n          _this3 = this;\n        log.debug(`${this._pcId} setRemoteDescription`);\n        if (!sessionDescription) {\n          return Promise.reject(new Error('No session description provided'));\n        }\n        var desc = {\n          type: sessionDescription.type,\n          sdp: (_sessionDescription$s2 = sessionDescription.sdp) != null ? _sessionDescription$s2 : ''\n        };\n        if (!RTCUtil.isSdpTypeValid((_desc$type = desc.type) != null ? _desc$type : '')) {\n          throw new Error(`Invalid session description: invalid type: ${desc.type}`);\n        }\n        var _yield$WebRTCModule$p4 = yield WebRTCModule.peerConnectionSetRemoteDescription(this._pcId, desc),\n          sdpInfo = _yield$WebRTCModule$p4.sdpInfo,\n          newTransceivers = _yield$WebRTCModule$p4.newTransceivers,\n          transceiversInfo = _yield$WebRTCModule$p4.transceiversInfo;\n        if (sdpInfo.type && sdpInfo.sdp) {\n          this.remoteDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n          this.remoteDescription = null;\n        }\n        newTransceivers === null || newTransceivers === void 0 ? void 0 : newTransceivers.forEach(function (t) {\n          var transceiverOrder = t.transceiverOrder,\n            transceiver = t.transceiver;\n          var newSender = new RTCRtpSender(_objectSpread(_objectSpread({}, transceiver.sender), {}, {\n            track: null\n          }));\n          var remoteTrack = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n          var newReceiver = new RTCRtpReceiver(_objectSpread(_objectSpread({}, transceiver.receiver), {}, {\n            track: remoteTrack\n          }));\n          var newTransceiver = new RTCRtpTransceiver(_objectSpread(_objectSpread({}, transceiver), {}, {\n            sender: newSender,\n            receiver: newReceiver\n          }));\n          _this3._insertTransceiverSorted(transceiverOrder, newTransceiver);\n        });\n        this._updateTransceivers(transceiversInfo, desc.type === 'answer');\n        var pendingTrackEvents = this._pendingTrackEvents;\n        this._pendingTrackEvents = [];\n        var _loop = function* _loop(ev) {\n          var _this3$getTransceiver = _this3.getTransceivers().filter(function (t) {\n              return t.receiver.id === ev.receiver.id;\n            }),\n            _this3$getTransceiver2 = _slicedToArray(_this3$getTransceiver, 1),\n            transceiver = _this3$getTransceiver2[0];\n          var track = transceiver.receiver.track;\n          transceiver._mid = ev.transceiver.mid;\n          transceiver._currentDirection = ev.transceiver.currentDirection;\n          transceiver._direction = ev.transceiver.direction;\n          var streams = ev.streams.map(function (streamInfo) {\n            if (!_this3._remoteStreams.has(streamInfo.streamId)) {\n              var _stream = new MediaStream({\n                streamId: streamInfo.streamId,\n                streamReactTag: streamInfo.streamReactTag,\n                tracks: []\n              });\n              _this3._remoteStreams.set(streamInfo.streamId, _stream);\n            }\n            var stream = _this3._remoteStreams.get(streamInfo.streamId);\n            if (!(stream !== null && stream !== void 0 && stream._tracks.includes(track))) {\n              stream === null || stream === void 0 ? void 0 : stream._tracks.push(track);\n            }\n            return stream;\n          });\n          var eventData = {\n            streams: streams,\n            transceiver: transceiver,\n            track: track,\n            receiver: transceiver.receiver\n          };\n          _this3.dispatchEvent(new RTCTrackEvent('track', eventData));\n          streams.forEach(function (stream) {\n            stream.dispatchEvent(new MediaStreamTrackEvent('addtrack', {\n              track: track\n            }));\n          });\n          track._setMutedInternal(false);\n        };\n        for (var ev of pendingTrackEvents) {\n          yield* _loop(ev);\n        }\n        log.debug(`${this._pcId} setRemoteDescription OK`);\n      });\n      function setRemoteDescription(_x3) {\n        return _setRemoteDescription.apply(this, arguments);\n      }\n      return setRemoteDescription;\n    }()\n  }, {\n    key: \"addIceCandidate\",\n    value: function () {\n      var _addIceCandidate = _asyncToGenerator(function* (candidate) {\n        log.debug(`${this._pcId} addIceCandidate`);\n        if (!candidate || !candidate.candidate) {\n          return;\n        }\n        if (candidate.sdpMLineIndex === null || candidate.sdpMLineIndex === undefined || candidate.sdpMid === null || candidate.sdpMid === undefined) {\n          throw new TypeError('`sdpMLineIndex` and `sdpMid` must not null or undefined');\n        }\n        var newSdp = yield WebRTCModule.peerConnectionAddICECandidate(this._pcId, candidate.toJSON ? candidate.toJSON() : candidate);\n        this.remoteDescription = new RTCSessionDescription(newSdp);\n      });\n      function addIceCandidate(_x4) {\n        return _addIceCandidate.apply(this, arguments);\n      }\n      return addIceCandidate;\n    }()\n  }, {\n    key: \"addTrack\",\n    value: function addTrack(track) {\n      log.debug(`${this._pcId} addTrack`);\n      if (this.connectionState === 'closed') {\n        throw new Error('Peer Connection is closed');\n      }\n      if (this._trackExists(track)) {\n        throw new Error('Track already exists in a sender');\n      }\n      for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        streams[_key - 1] = arguments[_key];\n      }\n      var streamIds = streams.map(function (s) {\n        return s.id;\n      });\n      var result = WebRTCModule.peerConnectionAddTrack(this._pcId, track.id, {\n        streamIds: streamIds\n      });\n      if (result === null) {\n        throw new Error('Could not add sender');\n      }\n      var transceiverOrder = result.transceiverOrder,\n        transceiver = result.transceiver,\n        sender = result.sender;\n      var _this$getSenders$filt = this.getSenders().filter(function (s) {\n          return s.id === sender.id;\n        }),\n        _this$getSenders$filt2 = _slicedToArray(_this$getSenders$filt, 1),\n        existingSender = _this$getSenders$filt2[0];\n      if (existingSender) {\n        existingSender._track = track;\n        var _this$getTransceivers = this.getTransceivers().filter(function (t) {\n            return t.sender.id === existingSender.id;\n          }),\n          _this$getTransceivers2 = _slicedToArray(_this$getTransceivers, 1),\n          existingTransceiver = _this$getTransceivers2[0];\n        existingTransceiver._direction = transceiver.direction;\n        existingTransceiver._currentDirection = transceiver.currentDirection;\n        return existingSender;\n      }\n      var newSender = new RTCRtpSender(_objectSpread(_objectSpread({}, transceiver.sender), {}, {\n        track: track\n      }));\n      var remoteTrack = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n      var newReceiver = new RTCRtpReceiver(_objectSpread(_objectSpread({}, transceiver.receiver), {}, {\n        track: remoteTrack\n      }));\n      var newTransceiver = new RTCRtpTransceiver(_objectSpread(_objectSpread({}, transceiver), {}, {\n        sender: newSender,\n        receiver: newReceiver\n      }));\n      this._insertTransceiverSorted(transceiverOrder, newTransceiver);\n      return newSender;\n    }\n  }, {\n    key: \"addTransceiver\",\n    value: function addTransceiver(source, init) {\n      log.debug(`${this._pcId} addTransceiver`);\n      var src = {};\n      if (source === 'audio') {\n        src = {\n          type: 'audio'\n        };\n      } else if (source === 'video') {\n        src = {\n          type: 'video'\n        };\n      } else {\n        src = {\n          trackId: source.id\n        };\n      }\n      if (init && init.streams) {\n        init.streamIds = init.streams.map(function (stream) {\n          return stream.id;\n        });\n      }\n      var result = WebRTCModule.peerConnectionAddTransceiver(this._pcId, _objectSpread(_objectSpread({}, src), {}, {\n        init: _objectSpread({}, init)\n      }));\n      if (result === null) {\n        throw new Error('Transceiver could not be added');\n      }\n      var t = result.transceiver;\n      var track = null;\n      if (typeof source === 'string') {\n        if (t.sender.track) {\n          track = new MediaStreamTrack(t.sender.track);\n        }\n      } else {\n        track = source;\n      }\n      var sender = new RTCRtpSender(_objectSpread(_objectSpread({}, t.sender), {}, {\n        track: track\n      }));\n      var remoteTrack = t.receiver.track ? new MediaStreamTrack(t.receiver.track) : null;\n      var receiver = new RTCRtpReceiver(_objectSpread(_objectSpread({}, t.receiver), {}, {\n        track: remoteTrack\n      }));\n      var transceiver = new RTCRtpTransceiver(_objectSpread(_objectSpread({}, result.transceiver), {}, {\n        sender: sender,\n        receiver: receiver\n      }));\n      this._insertTransceiverSorted(result.transceiverOrder, transceiver);\n      return transceiver;\n    }\n  }, {\n    key: \"removeTrack\",\n    value: function removeTrack(sender) {\n      log.debug(`${this._pcId} removeTrack`);\n      if (this._pcId !== sender._peerConnectionId) {\n        throw new Error('Sender does not belong to this peer connection');\n      }\n      if (this.connectionState === 'closed') {\n        throw new Error('Peer Connection is closed');\n      }\n      var existingSender = this.getSenders().find(function (s) {\n        return s === sender;\n      });\n      if (!existingSender) {\n        throw new Error('Sender does not exist');\n      }\n      if (existingSender.track === null) {\n        return;\n      }\n      WebRTCModule.peerConnectionRemoveTrack(this._pcId, sender.id);\n      existingSender._track = null;\n      var _this$getTransceivers3 = this.getTransceivers().filter(function (t) {\n          return t.sender.id === existingSender.id;\n        }),\n        _this$getTransceivers4 = _slicedToArray(_this$getTransceivers3, 1),\n        existingTransceiver = _this$getTransceivers4[0];\n      existingTransceiver._direction = existingTransceiver.direction === 'sendrecv' ? 'recvonly' : 'inactive';\n    }\n  }, {\n    key: \"getStats\",\n    value: function () {\n      var _getStats = _asyncToGenerator(function* (selector) {\n        log.debug(`${this._pcId} getStats`);\n        if (!selector) {\n          var data = yield WebRTCModule.peerConnectionGetStats(this._pcId);\n          return new Map(JSON.parse(data));\n        } else {\n          var senders = this.getSenders().filter(function (s) {\n            return s.track === selector;\n          });\n          var receivers = this.getReceivers().filter(function (r) {\n            return r.track === selector;\n          });\n          var matches = senders.length + receivers.length;\n          if (matches === 0) {\n            throw new Error('Invalid selector: could not find matching sender / receiver');\n          } else if (matches > 1) {\n            throw new Error('Invalid selector: multiple matching senders / receivers');\n          } else {\n            var sr = senders[0] || receivers[0];\n            return sr.getStats();\n          }\n        }\n      });\n      function getStats(_x5) {\n        return _getStats.apply(this, arguments);\n      }\n      return getStats;\n    }()\n  }, {\n    key: \"getTransceivers\",\n    value: function getTransceivers() {\n      return this._transceivers.map(function (e) {\n        return e.transceiver;\n      });\n    }\n  }, {\n    key: \"getSenders\",\n    value: function getSenders() {\n      return this._transceivers.map(function (e) {\n        return !e.transceiver.stopped && e.transceiver.sender;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"getReceivers\",\n    value: function getReceivers() {\n      return this._transceivers.map(function (e) {\n        return !e.transceiver.stopped && e.transceiver.receiver;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      log.debug(`${this._pcId} close`);\n      if (this.connectionState === 'closed') {\n        return;\n      }\n      WebRTCModule.peerConnectionClose(this._pcId);\n      this._transceivers.forEach(function (_ref) {\n        var transceiver = _ref.transceiver;\n        transceiver._setStopped();\n      });\n    }\n  }, {\n    key: \"restartIce\",\n    value: function restartIce() {\n      WebRTCModule.peerConnectionRestartIce(this._pcId);\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this4 = this;\n      addListener(this, 'peerConnectionOnRenegotiationNeeded', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        _this4.dispatchEvent(new Event('negotiationneeded'));\n      });\n      addListener(this, 'peerConnectionIceConnectionChanged', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        _this4.iceConnectionState = ev.iceConnectionState;\n        _this4.dispatchEvent(new Event('iceconnectionstatechange'));\n      });\n      addListener(this, 'peerConnectionStateChanged', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        _this4.connectionState = ev.connectionState;\n        _this4.dispatchEvent(new Event('connectionstatechange'));\n        if (ev.connectionState === 'closed') {\n          removeListener(_this4);\n          WebRTCModule.peerConnectionDispose(_this4._pcId);\n        }\n      });\n      addListener(this, 'peerConnectionSignalingStateChanged', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        _this4.signalingState = ev.signalingState;\n        _this4.dispatchEvent(new Event('signalingstatechange'));\n      });\n      addListener(this, 'peerConnectionOnTrack', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        log.debug(`${_this4._pcId} ontrack`);\n        _this4._pendingTrackEvents.push(ev);\n      });\n      addListener(this, 'peerConnectionOnRemoveTrack', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        log.debug(`${_this4._pcId} onremovetrack ${ev.receiverId}`);\n        var receiver = _this4.getReceivers().find(function (r) {\n          return r.id === ev.receiverId;\n        });\n        var track = receiver === null || receiver === void 0 ? void 0 : receiver.track;\n        if (receiver && track) {\n          for (var stream of _this4._remoteStreams.values()) {\n            if (stream._tracks.includes(track)) {\n              var trackIdx = stream._tracks.indexOf(track);\n              log.debug(`${_this4._pcId} removetrack ${track.id}`);\n              stream._tracks.splice(trackIdx, 1);\n              stream.dispatchEvent(new MediaStreamTrackEvent('removetrack', {\n                track: track\n              }));\n              track._setMutedInternal(true);\n            }\n          }\n        }\n      });\n      addListener(this, 'peerConnectionGotICECandidate', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        var sdpInfo = ev.sdp;\n        if (sdpInfo.type && sdpInfo.sdp) {\n          _this4.localDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n          _this4.localDescription = null;\n        }\n        var candidate = new RTCIceCandidate(ev.candidate);\n        _this4.dispatchEvent(new RTCIceCandidateEvent('icecandidate', {\n          candidate: candidate\n        }));\n      });\n      addListener(this, 'peerConnectionIceGatheringChanged', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        _this4.iceGatheringState = ev.iceGatheringState;\n        if (_this4.iceGatheringState === 'complete') {\n          var sdpInfo = ev.sdp;\n          if (sdpInfo.type && sdpInfo.sdp) {\n            _this4.localDescription = new RTCSessionDescription(sdpInfo);\n          } else {\n            _this4.localDescription = null;\n          }\n          _this4.dispatchEvent(new RTCIceCandidateEvent('icecandidate', {\n            candidate: null\n          }));\n        }\n        _this4.dispatchEvent(new Event('icegatheringstatechange'));\n      });\n      addListener(this, 'peerConnectionDidOpenDataChannel', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        var channel = new RTCDataChannel(ev.dataChannel);\n        _this4.dispatchEvent(new RTCDataChannelEvent('datachannel', {\n          channel: channel\n        }));\n      });\n      addListener(this, 'mediaStreamTrackMuteChanged', function (ev) {\n        if (ev.pcId !== _this4._pcId) {\n          return;\n        }\n        var _this4$getReceivers$m = _this4.getReceivers().map(function (r) {\n            return r.track;\n          }).filter(function (t) {\n            return (t === null || t === void 0 ? void 0 : t.id) === ev.trackId;\n          }),\n          _this4$getReceivers$m2 = _slicedToArray(_this4$getReceivers$m, 1),\n          track = _this4$getReceivers$m2[0];\n        if (track) {\n          track._setMutedInternal(ev.muted);\n        }\n      });\n    }\n  }, {\n    key: \"createDataChannel\",\n    value: function createDataChannel(label, dataChannelDict) {\n      if (dataChannelDict && 'id' in dataChannelDict) {\n        var id = dataChannelDict.id;\n        if (typeof id !== 'number') {\n          throw new TypeError('DataChannel id must be a number: ' + id);\n        }\n      }\n      var channelInfo = WebRTCModule.createDataChannel(this._pcId, label, dataChannelDict);\n      if (channelInfo === null) {\n        throw new TypeError('Failed to create new DataChannel');\n      }\n      return new RTCDataChannel(channelInfo);\n    }\n  }, {\n    key: \"_trackExists\",\n    value: function _trackExists(track) {\n      var _this$getSenders$filt3 = this.getSenders().filter(function (sender) {\n          var _sender$track;\n          return ((_sender$track = sender.track) === null || _sender$track === void 0 ? void 0 : _sender$track.id) === track.id;\n        }),\n        _this$getSenders$filt4 = _slicedToArray(_this$getSenders$filt3, 1),\n        sender = _this$getSenders$filt4[0];\n      return sender ? true : false;\n    }\n  }, {\n    key: \"_updateTransceivers\",\n    value: function _updateTransceivers(transceiverUpdates) {\n      var _this5 = this;\n      var removeStopped = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _loop2 = function _loop2(update) {\n        var _this5$getTransceiver = _this5.getTransceivers().filter(function (t) {\n            return t.sender.id === update.transceiverId;\n          }),\n          _this5$getTransceiver2 = _slicedToArray(_this5$getTransceiver, 1),\n          transceiver = _this5$getTransceiver2[0];\n        if (!transceiver) {\n          return 1;\n        }\n        if (update.currentDirection) {\n          transceiver._currentDirection = update.currentDirection;\n        }\n        transceiver._mid = update.mid;\n        transceiver._stopped = Boolean(update.isStopped);\n        transceiver._sender._rtpParameters = new RTCRtpSendParameters(update.senderRtpParameters);\n        transceiver._receiver._rtpParameters = new RTCRtpReceiveParameters(update.receiverRtpParameters);\n      };\n      for (var update of transceiverUpdates) {\n        if (_loop2(update)) continue;\n      }\n      if (removeStopped) {\n        var stopped = this.getTransceivers().filter(function (t) {\n          return t.stopped;\n        });\n        var newTransceivers = this._transceivers.filter(function (t) {\n          return !stopped.includes(t.transceiver);\n        });\n        this._transceivers = newTransceivers;\n      }\n    }\n  }, {\n    key: \"_insertTransceiverSorted\",\n    value: function _insertTransceiverSorted(order, transceiver) {\n      this._transceivers.push({\n        order: order,\n        transceiver: transceiver\n      });\n      this._transceivers.sort(function (a, b) {\n        return a.order - b.order;\n      });\n    }\n  }]);\n}(EventTarget);\nexport { RTCPeerConnection as default };\nvar proto = RTCPeerConnection.prototype;\ndefineEventAttribute(proto, 'connectionstatechange');\ndefineEventAttribute(proto, 'icecandidate');\ndefineEventAttribute(proto, 'icecandidateerror');\ndefineEventAttribute(proto, 'iceconnectionstatechange');\ndefineEventAttribute(proto, 'icegatheringstatechange');\ndefineEventAttribute(proto, 'negotiationneeded');\ndefineEventAttribute(proto, 'signalingstatechange');\ndefineEventAttribute(proto, 'datachannel');\ndefineEventAttribute(proto, 'track');\ndefineEventAttribute(proto, 'error');","map":{"version":3,"names":["EventTarget","Event","defineEventAttribute","NativeModules","addListener","removeListener","Logger","MediaStream","MediaStreamTrack","MediaStreamTrackEvent","RTCDataChannel","RTCDataChannelEvent","RTCIceCandidate","RTCIceCandidateEvent","RTCRtpReceiveParameters","RTCRtpReceiver","RTCRtpSendParameters","RTCRtpSender","RTCRtpTransceiver","RTCSessionDescription","RTCTrackEvent","RTCUtil","log","WebRTCModule","nextPeerConnectionId","RTCPeerConnection","_EventTarget","configuration","_this","_classCallCheck","_callSuper","localDescription","remoteDescription","signalingState","iceGatheringState","connectionState","iceConnectionState","_pcId","peerConnectionInit","Error","_transceivers","_remoteStreams","Map","_pendingTrackEvents","_registerEvents","debug","_inherits","_createClass","key","value","_createOffer","_asyncToGenerator","options","_this2","_yield$WebRTCModule$p","peerConnectionCreateOffer","normalizeOfferOptions","sdpInfo","newTransceivers","transceiversInfo","forEach","t","transceiverOrder","transceiver","newSender","_objectSpread","sender","track","remoteTrack","receiver","newReceiver","newTransceiver","_insertTransceiverSorted","_updateTransceivers","createOffer","_x","apply","arguments","_createAnswer","_yield$WebRTCModule$p2","peerConnectionCreateAnswer","createAnswer","setConfiguration","peerConnectionSetConfiguration","_setLocalDescription","sessionDescription","_desc","desc","_sessionDescription$s","type","sdp","isSdpTypeValid","_yield$WebRTCModule$p3","peerConnectionSetLocalDescription","setLocalDescription","_x2","_setRemoteDescription","_sessionDescription$s2","_desc$type","_this3","Promise","reject","_yield$WebRTCModule$p4","peerConnectionSetRemoteDescription","pendingTrackEvents","_loop","ev","_this3$getTransceiver","getTransceivers","filter","id","_this3$getTransceiver2","_slicedToArray","_mid","mid","_currentDirection","currentDirection","_direction","direction","streams","map","streamInfo","has","streamId","stream","streamReactTag","tracks","set","get","_tracks","includes","push","eventData","dispatchEvent","_setMutedInternal","setRemoteDescription","_x3","_addIceCandidate","candidate","sdpMLineIndex","undefined","sdpMid","TypeError","newSdp","peerConnectionAddICECandidate","toJSON","addIceCandidate","_x4","addTrack","_trackExists","_len","length","Array","_key","streamIds","s","result","peerConnectionAddTrack","_this$getSenders$filt","getSenders","_this$getSenders$filt2","existingSender","_track","_this$getTransceivers","_this$getTransceivers2","existingTransceiver","addTransceiver","source","init","src","trackId","peerConnectionAddTransceiver","removeTrack","_peerConnectionId","find","peerConnectionRemoveTrack","_this$getTransceivers3","_this$getTransceivers4","_getStats","selector","data","peerConnectionGetStats","JSON","parse","senders","receivers","getReceivers","r","matches","sr","getStats","_x5","e","stopped","Boolean","close","peerConnectionClose","_ref","_setStopped","restartIce","peerConnectionRestartIce","_this4","pcId","peerConnectionDispose","receiverId","values","trackIdx","indexOf","splice","channel","dataChannel","_this4$getReceivers$m","_this4$getReceivers$m2","muted","createDataChannel","label","dataChannelDict","channelInfo","_this$getSenders$filt3","_sender$track","_this$getSenders$filt4","transceiverUpdates","_this5","removeStopped","_loop2","update","_this5$getTransceiver","transceiverId","_this5$getTransceiver2","_stopped","isStopped","_sender","_rtpParameters","senderRtpParameters","_receiver","receiverRtpParameters","order","sort","a","b","default","proto","prototype"],"sources":["/workspaces/telemedicine-platform/mobile-app/node_modules/react-native-webrtc/src/RTCPeerConnection.ts"],"sourcesContent":["import { EventTarget, Event, defineEventAttribute } from 'event-target-shim';\nimport { NativeModules } from 'react-native';\n\nimport { addListener, removeListener } from './EventEmitter';\nimport Logger from './Logger';\nimport MediaStream from './MediaStream';\nimport MediaStreamTrack from './MediaStreamTrack';\nimport MediaStreamTrackEvent from './MediaStreamTrackEvent';\nimport RTCDataChannel from './RTCDataChannel';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\nimport RTCIceCandidate from './RTCIceCandidate';\nimport RTCIceCandidateEvent from './RTCIceCandidateEvent';\nimport RTCRtpReceiveParameters from './RTCRtpReceiveParameters';\nimport RTCRtpReceiver from './RTCRtpReceiver';\nimport RTCRtpSendParameters from './RTCRtpSendParameters';\nimport RTCRtpSender from './RTCRtpSender';\nimport RTCRtpTransceiver from './RTCRtpTransceiver';\nimport RTCSessionDescription, { RTCSessionDescriptionInit } from './RTCSessionDescription';\nimport RTCTrackEvent from './RTCTrackEvent';\nimport * as RTCUtil from './RTCUtil';\n\nconst log = new Logger('pc');\nconst { WebRTCModule } = NativeModules;\n\ntype RTCSignalingState =\n    | 'stable'\n    | 'have-local-offer'\n    | 'have-remote-offer'\n    | 'have-local-pranswer'\n    | 'have-remote-pranswer'\n    | 'closed';\n\ntype RTCIceGatheringState = 'new' | 'gathering' | 'complete';\n\ntype RTCPeerConnectionState = 'new' | 'connecting' | 'connected' | 'disconnected' | 'failed' | 'closed';\n\ntype RTCIceConnectionState = 'new' | 'checking' | 'connected' | 'completed' | 'failed' | 'disconnected' | 'closed';\n\ntype RTCDataChannelInit = {\n    ordered?: boolean,\n    maxPacketLifeTime?: number,\n    maxRetransmits?: number,\n    protocol?: string,\n    negotiated?: boolean,\n    id?: number\n};\n\ntype RTCPeerConnectionEventMap = {\n    connectionstatechange: Event<'connectionstatechange'>\n    icecandidate: RTCIceCandidateEvent<'icecandidate'>\n    icecandidateerror: RTCIceCandidateEvent<'icecandidateerror'>\n    iceconnectionstatechange: Event<'iceconnectionstatechange'>\n    icegatheringstatechange: Event<'icegatheringstatechange'>\n    negotiationneeded: Event<'negotiationneeded'>\n    signalingstatechange: Event<'signalingstatechange'>\n    datachannel: RTCDataChannelEvent<'datachannel'>\n    track: RTCTrackEvent<'track'>\n    error: Event<'error'>\n}\n\nlet nextPeerConnectionId = 0;\n\nexport default class RTCPeerConnection extends EventTarget<RTCPeerConnectionEventMap> {\n    localDescription: RTCSessionDescription | null = null;\n    remoteDescription: RTCSessionDescription | null = null;\n    signalingState: RTCSignalingState = 'stable';\n    iceGatheringState: RTCIceGatheringState = 'new';\n    connectionState: RTCPeerConnectionState = 'new';\n    iceConnectionState: RTCIceConnectionState = 'new';\n\n    _pcId: number;\n    _transceivers: { order: number, transceiver: RTCRtpTransceiver }[];\n    _remoteStreams: Map<string, MediaStream>;\n    _pendingTrackEvents: any[];\n\n    constructor(configuration) {\n        super();\n\n        this._pcId = nextPeerConnectionId++;\n\n        if (!WebRTCModule.peerConnectionInit(configuration, this._pcId)) {\n            throw new Error('Failed to initialize PeerConnection, check the native logs!');\n        }\n\n        this._transceivers = [];\n        this._remoteStreams = new Map();\n        this._pendingTrackEvents = [];\n\n        this._registerEvents();\n\n        log.debug(`${this._pcId} ctor`);\n    }\n\n    async createOffer(options) {\n        log.debug(`${this._pcId} createOffer`);\n\n        const {\n            sdpInfo,\n            newTransceivers,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionCreateOffer(this._pcId, RTCUtil.normalizeOfferOptions(options));\n\n        log.debug(`${this._pcId} createOffer OK`);\n\n        newTransceivers?.forEach(t => {\n            const { transceiverOrder, transceiver } = t;\n            const newSender = new RTCRtpSender({ ...transceiver.sender, track: null });\n            const remoteTrack\n                = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n            const newReceiver = new RTCRtpReceiver({ ...transceiver.receiver, track: remoteTrack });\n            const newTransceiver = new RTCRtpTransceiver({\n                ...transceiver,\n                sender: newSender,\n                receiver: newReceiver,\n            });\n\n            this._insertTransceiverSorted(transceiverOrder, newTransceiver);\n        });\n\n        this._updateTransceivers(transceiversInfo);\n\n        return sdpInfo;\n    }\n\n    async createAnswer() {\n        log.debug(`${this._pcId} createAnswer`);\n\n        const {\n            sdpInfo,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionCreateAnswer(this._pcId, {});\n\n        this._updateTransceivers(transceiversInfo);\n\n        return sdpInfo;\n    }\n\n    setConfiguration(configuration): void {\n        WebRTCModule.peerConnectionSetConfiguration(configuration, this._pcId);\n    }\n\n    async setLocalDescription(sessionDescription?: RTCSessionDescription | RTCSessionDescriptionInit): Promise<void> {\n        log.debug(`${this._pcId} setLocalDescription`);\n\n        let desc;\n\n        if (sessionDescription) {\n            desc = {\n                type: sessionDescription.type,\n                sdp: sessionDescription.sdp ?? ''\n            };\n\n            if (!RTCUtil.isSdpTypeValid(desc.type)) {\n                throw new Error(`Invalid session description: invalid type: ${desc.type}`);\n            }\n        } else {\n            desc = null;\n        }\n\n        const {\n            sdpInfo,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionSetLocalDescription(this._pcId, desc);\n\n        if (sdpInfo.type && sdpInfo.sdp) {\n            this.localDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n            this.localDescription = null;\n        }\n\n        this._updateTransceivers(transceiversInfo, /* removeStopped */ desc?.type === 'answer');\n\n        log.debug(`${this._pcId} setLocalDescription OK`);\n    }\n\n    async setRemoteDescription(sessionDescription: RTCSessionDescription | RTCSessionDescriptionInit): Promise<void> {\n        log.debug(`${this._pcId} setRemoteDescription`);\n\n        if (!sessionDescription) {\n            return Promise.reject(new Error('No session description provided'));\n        }\n\n        const desc = {\n            type: sessionDescription.type,\n            sdp: sessionDescription.sdp ?? ''\n        };\n\n        if (!RTCUtil.isSdpTypeValid(desc.type ?? '')) {\n            throw new Error(`Invalid session description: invalid type: ${desc.type}`);\n        }\n\n        const {\n            sdpInfo,\n            newTransceivers,\n            transceiversInfo\n        } = await WebRTCModule.peerConnectionSetRemoteDescription(this._pcId, desc);\n\n        if (sdpInfo.type && sdpInfo.sdp) {\n            this.remoteDescription = new RTCSessionDescription(sdpInfo);\n        } else {\n            this.remoteDescription = null;\n        }\n\n        newTransceivers?.forEach(t => {\n            const { transceiverOrder, transceiver } = t;\n            const newSender = new RTCRtpSender({ ...transceiver.sender, track: null });\n            const remoteTrack\n                = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n            const newReceiver = new RTCRtpReceiver({ ...transceiver.receiver, track: remoteTrack });\n            const newTransceiver = new RTCRtpTransceiver({\n                ...transceiver,\n                sender: newSender,\n                receiver: newReceiver,\n            });\n\n            this._insertTransceiverSorted(transceiverOrder, newTransceiver);\n        });\n\n        this._updateTransceivers(transceiversInfo, /* removeStopped */ desc.type === 'answer');\n\n        // Fire track events. They must fire before sRD resolves.\n        const pendingTrackEvents = this._pendingTrackEvents;\n\n        this._pendingTrackEvents = [];\n\n        for (const ev of pendingTrackEvents) {\n            const [ transceiver ] = this\n                .getTransceivers()\n                .filter(t => t.receiver.id ===  ev.receiver.id);\n\n            // We need to fire this event for an existing track sometimes, like\n            // when the transceiver direction (on the sending side) switches from\n            // sendrecv to recvonly and then back.\n\n            // @ts-ignore\n            const track: MediaStreamTrack = transceiver.receiver.track;\n\n            transceiver._mid = ev.transceiver.mid;\n            transceiver._currentDirection = ev.transceiver.currentDirection;\n            transceiver._direction = ev.transceiver.direction;\n\n            // Get the stream object from the event. Create if necessary.\n            const streams: MediaStream[] = ev.streams.map(streamInfo => {\n                // Here we are making sure that we don't create stream objects that already exist\n                // So that event listeners do get the same object if it has been created before.\n                if (!this._remoteStreams.has(streamInfo.streamId)) {\n                    const stream = new MediaStream({\n                        streamId: streamInfo.streamId,\n                        streamReactTag: streamInfo.streamReactTag,\n                        tracks: []\n                    });\n\n                    this._remoteStreams.set(streamInfo.streamId, stream);\n                }\n\n                const stream = this._remoteStreams.get(streamInfo.streamId);\n\n                if (!stream?._tracks.includes(track)) {\n                    stream?._tracks.push(track);\n                }\n\n                return stream;\n            });\n\n            const eventData = {\n                streams,\n                transceiver,\n                track,\n                receiver: transceiver.receiver\n            };\n\n\n            this.dispatchEvent(new RTCTrackEvent('track', eventData));\n\n            streams.forEach(stream => {\n                stream.dispatchEvent(new MediaStreamTrackEvent('addtrack', { track }));\n            });\n\n            // Dispatch an unmute event for the track.\n            track._setMutedInternal(false);\n        }\n\n        log.debug(`${this._pcId} setRemoteDescription OK`);\n    }\n\n    async addIceCandidate(candidate): Promise<void> {\n        log.debug(`${this._pcId} addIceCandidate`);\n\n        if (!candidate || !candidate.candidate) {\n            // XXX end-of candidates is not implemented: https://bugs.chromium.org/p/webrtc/issues/detail?id=9218\n            return;\n        }\n\n        if (\n            candidate.sdpMLineIndex === null ||\n            candidate.sdpMLineIndex === undefined ||\n            candidate.sdpMid === null ||\n            candidate.sdpMid === undefined\n        ) {\n            throw new TypeError('`sdpMLineIndex` and `sdpMid` must not null or undefined');\n        }\n\n        const newSdp = await WebRTCModule.peerConnectionAddICECandidate(\n            this._pcId,\n            candidate.toJSON ? candidate.toJSON() : candidate\n        );\n\n        this.remoteDescription = new RTCSessionDescription(newSdp);\n    }\n\n    /**\n     * @brief Adds a new track to the {@link RTCPeerConnection},\n     * and indicates that it is contained in the specified {@link MediaStream}s.\n     * This method has to be synchronous as the W3C API expects a track to be returned\n     * @param {MediaStreamTrack} track The track to be added\n     * @param {...MediaStream} streams One or more {@link MediaStream}s the track needs to be added to\n     * https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addtrack\n     */\n    addTrack(track: MediaStreamTrack, ...streams: MediaStream[]): RTCRtpSender {\n        log.debug(`${this._pcId} addTrack`);\n\n        if (this.connectionState === 'closed') {\n            throw new Error('Peer Connection is closed');\n        }\n\n        if (this._trackExists(track)) {\n            throw new Error('Track already exists in a sender');\n        }\n\n        const streamIds = streams.map(s => s.id);\n        const result = WebRTCModule.peerConnectionAddTrack(this._pcId, track.id, { streamIds });\n\n        if (result === null) {\n            throw new Error('Could not add sender');\n        }\n\n        const { transceiverOrder, transceiver, sender } = result;\n\n        // According to the W3C docs, the sender could have been reused, and\n        // so we check if that is the case, and update accordingly.\n        const [ existingSender ] = this\n            .getSenders()\n            .filter(s => s.id === sender.id);\n\n        if (existingSender) {\n            // Update sender\n            existingSender._track = track;\n\n            // Update the corresponding transceiver as well\n            const [ existingTransceiver ] = this\n                .getTransceivers()\n                .filter(t => t.sender.id === existingSender.id);\n\n            existingTransceiver._direction = transceiver.direction;\n            existingTransceiver._currentDirection = transceiver.currentDirection;\n\n            return existingSender;\n        }\n\n        // This is a new transceiver, should create a transceiver for it and add it\n        const newSender = new RTCRtpSender({ ...transceiver.sender, track });\n        const remoteTrack = transceiver.receiver.track ? new MediaStreamTrack(transceiver.receiver.track) : null;\n        const newReceiver = new RTCRtpReceiver({ ...transceiver.receiver, track: remoteTrack });\n        const newTransceiver = new RTCRtpTransceiver({\n            ...transceiver,\n            sender: newSender,\n            receiver: newReceiver,\n        });\n\n        this._insertTransceiverSorted(transceiverOrder, newTransceiver);\n\n        return newSender;\n    }\n\n    addTransceiver(source: 'audio' | 'video' | MediaStreamTrack, init): RTCRtpTransceiver {\n        log.debug(`${this._pcId} addTransceiver`);\n\n        let src = {};\n\n        if (source === 'audio') {\n            src = { type: 'audio' };\n        } else if (source === 'video') {\n            src = { type: 'video' };\n        } else {\n            src = { trackId: source.id };\n        }\n\n        // Extract the stream ids\n        if (init && init.streams) {\n            init.streamIds = init.streams.map(stream => stream.id);\n        }\n\n        const result = WebRTCModule.peerConnectionAddTransceiver(this._pcId, { ...src, init: { ...init } });\n\n        if (result === null) {\n            throw new Error('Transceiver could not be added');\n        }\n\n        const t = result.transceiver;\n        let track: MediaStreamTrack | null = null;\n\n        if (typeof source === 'string') {\n            if (t.sender.track) {\n                track = new MediaStreamTrack(t.sender.track);\n            }\n        } else {\n            // 'source' is a MediaStreamTrack\n            track = source;\n        }\n\n        const sender = new RTCRtpSender({ ...t.sender, track });\n        const remoteTrack = t.receiver.track ? new MediaStreamTrack(t.receiver.track) : null;\n        const receiver = new RTCRtpReceiver({ ...t.receiver, track: remoteTrack });\n        const transceiver = new RTCRtpTransceiver({\n            ...result.transceiver,\n            sender,\n            receiver\n        });\n\n        this._insertTransceiverSorted(result.transceiverOrder, transceiver);\n\n        return transceiver;\n    }\n\n    removeTrack(sender: RTCRtpSender) {\n        log.debug(`${this._pcId} removeTrack`);\n\n        if (this._pcId !== sender._peerConnectionId) {\n            throw new Error('Sender does not belong to this peer connection');\n        }\n\n        if (this.connectionState === 'closed') {\n            throw new Error('Peer Connection is closed');\n        }\n\n        const existingSender = this\n            .getSenders()\n            .find(s => s === sender);\n\n        if (!existingSender) {\n            throw new Error('Sender does not exist');\n        }\n\n        if (existingSender.track === null) {\n            return;\n        }\n\n        // Blocking!\n        WebRTCModule.peerConnectionRemoveTrack(this._pcId, sender.id);\n\n        existingSender._track = null;\n\n        const [ existingTransceiver ] = this\n            .getTransceivers()\n            .filter(t => t.sender.id === existingSender.id);\n\n        existingTransceiver._direction = existingTransceiver.direction === 'sendrecv' ? 'recvonly' : 'inactive';\n    }\n\n    async getStats(selector?: MediaStreamTrack) {\n        log.debug(`${this._pcId} getStats`);\n\n        if (!selector) {\n            const data = await WebRTCModule.peerConnectionGetStats(this._pcId);\n\n            /**\n             * On both Android and iOS it is faster to construct a single\n             * JSON string representing the Map of StatsReports and have it\n             * pass through the React Native bridge rather than the Map of\n             * StatsReports. While the implementations do try to be faster in\n             * general, the stress is on being faster to pass through the React\n             * Native bridge which is a bottleneck that tends to be visible in\n             * the UI when there is congestion involving UI-related passing.\n             */\n            return new Map(JSON.parse(data));\n        } else {\n            const senders = this.getSenders().filter(s => s.track === selector);\n            const receivers = this.getReceivers().filter(r => r.track === selector);\n            const matches = senders.length + receivers.length;\n\n            if (matches === 0) {\n                throw new Error('Invalid selector: could not find matching sender / receiver');\n            } else if (matches > 1) {\n                throw new Error('Invalid selector: multiple matching senders / receivers');\n            } else {\n                const sr = senders[0] || receivers[0];\n\n                return sr.getStats();\n            }\n        }\n    }\n\n    getTransceivers(): RTCRtpTransceiver[] {\n        return this._transceivers.map(e => e.transceiver);\n    }\n\n    getSenders(): RTCRtpSender[] {\n        // @ts-ignore\n        return this._transceivers.map(e => !e.transceiver.stopped && e.transceiver.sender).filter(Boolean);\n    }\n\n    getReceivers(): RTCRtpReceiver[] {\n        // @ts-ignore\n        return this._transceivers.map(e => !e.transceiver.stopped && e.transceiver.receiver).filter(Boolean);\n    }\n\n    close(): void {\n        log.debug(`${this._pcId} close`);\n\n        if (this.connectionState === 'closed') {\n            return;\n        }\n\n        WebRTCModule.peerConnectionClose(this._pcId);\n\n        // Mark transceivers as stopped.\n        this._transceivers.forEach(({ transceiver })=> {\n            transceiver._setStopped();\n        });\n    }\n\n    restartIce(): void {\n        WebRTCModule.peerConnectionRestartIce(this._pcId);\n    }\n\n    _registerEvents(): void {\n        addListener(this, 'peerConnectionOnRenegotiationNeeded', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.dispatchEvent(new Event('negotiationneeded'));\n        });\n\n        addListener(this, 'peerConnectionIceConnectionChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.iceConnectionState = ev.iceConnectionState;\n\n            this.dispatchEvent(new Event('iceconnectionstatechange'));\n        });\n\n        addListener(this, 'peerConnectionStateChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.connectionState = ev.connectionState;\n\n            this.dispatchEvent(new Event('connectionstatechange'));\n\n            if (ev.connectionState === 'closed') {\n                // This PeerConnection is done, clean up.\n                removeListener(this);\n\n                WebRTCModule.peerConnectionDispose(this._pcId);\n            }\n        });\n\n        addListener(this, 'peerConnectionSignalingStateChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.signalingState = ev.signalingState;\n\n            this.dispatchEvent(new Event('signalingstatechange'));\n        });\n\n        // Consider moving away from this event: https://github.com/WebKit/WebKit/pull/3953\n        addListener(this, 'peerConnectionOnTrack', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            log.debug(`${this._pcId} ontrack`);\n\n            // NOTE: We need to make sure the track event fires right before sRD completes,\n            // so we queue them up here and dispatch the events when sRD fires, but before completing it.\n            // In the future we should probably implement out own logic and drop this event altogether.\n            this._pendingTrackEvents.push(ev);\n        });\n\n        addListener(this, 'peerConnectionOnRemoveTrack', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            log.debug(`${this._pcId} onremovetrack ${ev.receiverId}`);\n\n            const receiver = this.getReceivers().find(r => r.id === ev.receiverId);\n            const track = receiver?.track;\n\n            if (receiver && track) {\n                // As per the spec:\n                // - Remove the track from any media streams that were previously passed to the `track` event.\n                // https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-removetrack,\n                // - Mark the track as muted:\n                // https://w3c.github.io/webrtc-pc/#process-remote-track-removal\n                for (const stream of this._remoteStreams.values()) {\n                    if (stream._tracks.includes(track)) {\n                        const trackIdx = stream._tracks.indexOf(track);\n\n                        log.debug(`${this._pcId} removetrack ${track.id}`);\n\n                        stream._tracks.splice(trackIdx, 1);\n\n                        stream.dispatchEvent(new MediaStreamTrackEvent('removetrack', { track }));\n\n                        // Dispatch a mute event for the track.\n                        track._setMutedInternal(true);\n                    }\n                }\n            }\n        });\n\n        addListener(this, 'peerConnectionGotICECandidate', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            const sdpInfo = ev.sdp;\n\n            // Can happen when doing a rollback.\n            if (sdpInfo.type && sdpInfo.sdp) {\n                this.localDescription = new RTCSessionDescription(sdpInfo);\n            } else {\n                this.localDescription = null;\n            }\n\n            const candidate = new RTCIceCandidate(ev.candidate);\n\n            this.dispatchEvent(new RTCIceCandidateEvent('icecandidate', { candidate }));\n        });\n\n        addListener(this, 'peerConnectionIceGatheringChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            this.iceGatheringState = ev.iceGatheringState;\n\n            if (this.iceGatheringState === 'complete') {\n                const sdpInfo = ev.sdp;\n\n                // Can happen when doing a rollback.\n                if (sdpInfo.type && sdpInfo.sdp) {\n                    this.localDescription = new RTCSessionDescription(sdpInfo);\n                } else {\n                    this.localDescription = null;\n                }\n\n                this.dispatchEvent(new RTCIceCandidateEvent('icecandidate', { candidate: null }));\n            }\n\n            this.dispatchEvent(new Event('icegatheringstatechange'));\n        });\n\n        addListener(this, 'peerConnectionDidOpenDataChannel', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            const channel = new RTCDataChannel(ev.dataChannel);\n\n            this.dispatchEvent(new RTCDataChannelEvent('datachannel', { channel }));\n        });\n\n        addListener(this, 'mediaStreamTrackMuteChanged', (ev: any) => {\n            if (ev.pcId !== this._pcId) {\n                return;\n            }\n\n            const [\n                track\n            ] = this.getReceivers().map(r => r.track).filter(t => t?.id === ev.trackId);\n\n            if (track) {\n                track._setMutedInternal(ev.muted);\n            }\n        });\n    }\n\n    /**\n     * Creates a new RTCDataChannel object with the given label. The\n     * RTCDataChannelInit dictionary can be used to configure properties of the\n     * underlying channel such as data reliability.\n     *\n     * @param {string} label - the value with which the label attribute of the new\n     * instance is to be initialized\n     * @param {RTCDataChannelInit} dataChannelDict - an optional dictionary of\n     * values with which to initialize corresponding attributes of the new\n     * instance such as id\n     */\n    createDataChannel(label: string, dataChannelDict?: RTCDataChannelInit): RTCDataChannel {\n        if (dataChannelDict && 'id' in dataChannelDict) {\n            const id = dataChannelDict.id;\n\n            if (typeof id !== 'number') {\n                throw new TypeError('DataChannel id must be a number: ' + id);\n            }\n        }\n\n        const channelInfo = WebRTCModule.createDataChannel(this._pcId, label, dataChannelDict);\n\n        if (channelInfo === null) {\n            throw new TypeError('Failed to create new DataChannel');\n        }\n\n        return new RTCDataChannel(channelInfo);\n    }\n\n    /**\n     * Check whether a media stream track exists already in a sender.\n     * See https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-addtrack for more information\n     */\n    _trackExists(track: MediaStreamTrack): boolean {\n        const [ sender ] = this\n            .getSenders()\n            .filter(\n                sender => sender.track?.id === track.id\n            );\n\n        return sender? true : false;\n    }\n\n    /**\n     * Updates transceivers after offer/answer updates if necessary.\n     */\n    _updateTransceivers(transceiverUpdates, removeStopped = false) {\n        for (const update of transceiverUpdates) {\n            const [ transceiver ] = this\n                .getTransceivers()\n                .filter(t => t.sender.id === update.transceiverId);\n\n            if (!transceiver) {\n                continue;\n            }\n\n            if (update.currentDirection) {\n                transceiver._currentDirection = update.currentDirection;\n            }\n\n            transceiver._mid = update.mid;\n            transceiver._stopped = Boolean(update.isStopped);\n            transceiver._sender._rtpParameters = new RTCRtpSendParameters(update.senderRtpParameters);\n            transceiver._receiver._rtpParameters = new RTCRtpReceiveParameters(update.receiverRtpParameters);\n        }\n\n        if (removeStopped) {\n            const stopped = this.getTransceivers().filter(t => t.stopped);\n            const newTransceivers = this._transceivers.filter(t => !stopped.includes(t.transceiver));\n\n            this._transceivers = newTransceivers;\n        }\n    }\n\n    /**\n     * Inserts transceiver into the transceiver array in the order they are created (timestamp).\n     * @param order an index that refers to when it it was created relatively.\n     * @param transceiver the transceiver object to be inserted.\n     */\n    _insertTransceiverSorted(order: number, transceiver: RTCRtpTransceiver) {\n        this._transceivers.push({ order, transceiver });\n        this._transceivers.sort((a, b) => a.order - b.order);\n    }\n}\n\n/**\n * Define the `onxxx` event handlers.\n */\nconst proto = RTCPeerConnection.prototype;\n\ndefineEventAttribute(proto, 'connectionstatechange');\ndefineEventAttribute(proto, 'icecandidate');\ndefineEventAttribute(proto, 'icecandidateerror');\ndefineEventAttribute(proto, 'iceconnectionstatechange');\ndefineEventAttribute(proto, 'icegatheringstatechange');\ndefineEventAttribute(proto, 'negotiationneeded');\ndefineEventAttribute(proto, 'signalingstatechange');\ndefineEventAttribute(proto, 'datachannel');\ndefineEventAttribute(proto, 'track');\ndefineEventAttribute(proto, 'error');\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}