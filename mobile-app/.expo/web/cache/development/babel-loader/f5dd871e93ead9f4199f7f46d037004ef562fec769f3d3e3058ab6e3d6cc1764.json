{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nimport * as base64 from 'base64-js';\nimport { EventTarget, defineEventAttribute } from 'event-target-shim';\nimport NativeModules from \"react-native-web/dist/exports/NativeModules\";\nimport { addListener, removeListener } from \"./EventEmitter\";\nimport MessageEvent from \"./MessageEvent\";\nimport RTCDataChannelEvent from \"./RTCDataChannelEvent\";\nvar WebRTCModule = NativeModules.WebRTCModule;\nvar RTCDataChannel = function (_EventTarget) {\n  function RTCDataChannel(info) {\n    var _this;\n    _classCallCheck(this, RTCDataChannel);\n    _this = _callSuper(this, RTCDataChannel);\n    _this.binaryType = 'arraybuffer';\n    _this.bufferedAmountLowThreshold = 0;\n    _this._peerConnectionId = info.peerConnectionId;\n    _this._reactTag = info.reactTag;\n    _this._bufferedAmount = 0;\n    _this._label = info.label;\n    _this._id = info.id === -1 ? null : info.id;\n    _this._ordered = Boolean(info.ordered);\n    _this._maxPacketLifeTime = info.maxPacketLifeTime;\n    _this._maxRetransmits = info.maxRetransmits;\n    _this._protocol = info.protocol || '';\n    _this._negotiated = Boolean(info.negotiated);\n    _this._readyState = info.readyState;\n    _this._registerEvents();\n    return _this;\n  }\n  _inherits(RTCDataChannel, _EventTarget);\n  return _createClass(RTCDataChannel, [{\n    key: \"bufferedAmount\",\n    get: function get() {\n      return this._bufferedAmount;\n    }\n  }, {\n    key: \"label\",\n    get: function get() {\n      return this._label;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: \"ordered\",\n    get: function get() {\n      return this._ordered;\n    }\n  }, {\n    key: \"maxPacketLifeTime\",\n    get: function get() {\n      return this._maxPacketLifeTime;\n    }\n  }, {\n    key: \"maxRetransmits\",\n    get: function get() {\n      return this._maxRetransmits;\n    }\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._protocol;\n    }\n  }, {\n    key: \"negotiated\",\n    get: function get() {\n      return this._negotiated;\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._readyState;\n    }\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      if (typeof data === 'string') {\n        WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, data, 'text');\n        return;\n      }\n      if (ArrayBuffer.isView(data)) {\n        data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n      } else if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n      } else {\n        throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n      }\n      var base64data = base64.fromByteArray(data);\n      WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, base64data, 'binary');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._readyState === 'closing' || this._readyState === 'closed') {\n        return;\n      }\n      WebRTCModule.dataChannelClose(this._peerConnectionId, this._reactTag);\n    }\n  }, {\n    key: \"_registerEvents\",\n    value: function _registerEvents() {\n      var _this2 = this;\n      addListener(this, 'dataChannelStateChanged', function (ev) {\n        if (ev.reactTag !== _this2._reactTag) {\n          return;\n        }\n        _this2._readyState = ev.state;\n        if (_this2._id === null && ev.id !== -1) {\n          _this2._id = ev.id;\n        }\n        if (_this2._readyState === 'open') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('open', {\n            channel: _this2\n          }));\n        } else if (_this2._readyState === 'closing') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('closing', {\n            channel: _this2\n          }));\n        } else if (_this2._readyState === 'closed') {\n          _this2.dispatchEvent(new RTCDataChannelEvent('close', {\n            channel: _this2\n          }));\n          removeListener(_this2);\n          WebRTCModule.dataChannelDispose(_this2._peerConnectionId, _this2._reactTag);\n        }\n      });\n      addListener(this, 'dataChannelReceiveMessage', function (ev) {\n        if (ev.reactTag !== _this2._reactTag) {\n          return;\n        }\n        var data = ev.data;\n        if (ev.type === 'binary') {\n          data = base64.toByteArray(ev.data).buffer;\n        }\n        _this2.dispatchEvent(new MessageEvent('message', {\n          data: data\n        }));\n      });\n      addListener(this, 'dataChannelDidChangeBufferedAmount', function (ev) {\n        if (ev.reactTag !== _this2._reactTag) {\n          return;\n        }\n        _this2._bufferedAmount = ev.bufferedAmount;\n        if (_this2._bufferedAmount < _this2.bufferedAmountLowThreshold) {\n          _this2.dispatchEvent(new RTCDataChannelEvent('bufferedamountlow', {\n            channel: _this2\n          }));\n        }\n      });\n    }\n  }]);\n}(EventTarget);\nexport { RTCDataChannel as default };\nvar proto = RTCDataChannel.prototype;\ndefineEventAttribute(proto, 'bufferedamountlow');\ndefineEventAttribute(proto, 'close');\ndefineEventAttribute(proto, 'closing');\ndefineEventAttribute(proto, 'error');\ndefineEventAttribute(proto, 'message');\ndefineEventAttribute(proto, 'open');","map":{"version":3,"names":["base64","EventTarget","defineEventAttribute","NativeModules","addListener","removeListener","MessageEvent","RTCDataChannelEvent","WebRTCModule","RTCDataChannel","_EventTarget","info","_this","_classCallCheck","_callSuper","binaryType","bufferedAmountLowThreshold","_peerConnectionId","peerConnectionId","_reactTag","reactTag","_bufferedAmount","_label","label","_id","id","_ordered","Boolean","ordered","_maxPacketLifeTime","maxPacketLifeTime","_maxRetransmits","maxRetransmits","_protocol","protocol","_negotiated","negotiated","_readyState","readyState","_registerEvents","_inherits","_createClass","key","get","value","send","data","dataChannelSend","ArrayBuffer","isView","Uint8Array","buffer","byteOffset","byteLength","TypeError","base64data","fromByteArray","close","dataChannelClose","_this2","ev","state","dispatchEvent","channel","dataChannelDispose","type","toByteArray","bufferedAmount","default","proto","prototype"],"sources":["/workspaces/telemedicine-platform/mobile-app/node_modules/react-native-webrtc/src/RTCDataChannel.ts"],"sourcesContent":["import * as base64 from 'base64-js';\nimport { EventTarget, defineEventAttribute } from 'event-target-shim';\nimport { NativeModules } from 'react-native';\n\nimport { addListener, removeListener } from './EventEmitter';\nimport MessageEvent from './MessageEvent';\nimport RTCDataChannelEvent from './RTCDataChannelEvent';\n\nconst { WebRTCModule } = NativeModules;\n\ntype RTCDataChannelState = 'connecting' | 'open' | 'closing' | 'closed';\n\ntype DataChannelEventMap = {\n    bufferedamountlow: RTCDataChannelEvent<'bufferedamountlow'>;\n    close: RTCDataChannelEvent<'close'>;\n    closing: RTCDataChannelEvent<'closing'>;\n    error: RTCDataChannelEvent<'error'>;\n    message: MessageEvent<'message'>;\n    open: RTCDataChannelEvent<'open'>;\n};\n\nexport default class RTCDataChannel extends EventTarget<DataChannelEventMap> {\n    _peerConnectionId: number;\n    _reactTag: string;\n\n    _bufferedAmount: number;\n    _id: number;\n    _label: string;\n    _maxPacketLifeTime?: number;\n    _maxRetransmits?: number;\n    _negotiated: boolean;\n    _ordered: boolean;\n    _protocol: string;\n    _readyState: RTCDataChannelState;\n\n    binaryType = 'arraybuffer'; // we only support 'arraybuffer'\n    bufferedAmountLowThreshold = 0;\n\n    constructor(info) {\n        super();\n\n        this._peerConnectionId = info.peerConnectionId;\n        this._reactTag = info.reactTag;\n\n        this._bufferedAmount = 0;\n        this._label = info.label;\n        this._id = info.id === -1 ? null : info.id; // null until negotiated.\n        this._ordered = Boolean(info.ordered);\n        this._maxPacketLifeTime = info.maxPacketLifeTime;\n        this._maxRetransmits = info.maxRetransmits;\n        this._protocol = info.protocol || '';\n        this._negotiated = Boolean(info.negotiated);\n        this._readyState = info.readyState;\n\n        this._registerEvents();\n    }\n\n    get bufferedAmount(): number {\n        return this._bufferedAmount;\n    }\n\n    get label(): string {\n        return this._label;\n    }\n\n    get id(): number {\n        return this._id;\n    }\n\n    get ordered(): boolean {\n        return this._ordered;\n    }\n\n    get maxPacketLifeTime(): number | undefined {\n        return this._maxPacketLifeTime;\n    }\n\n    get maxRetransmits(): number | undefined {\n        return this._maxRetransmits;\n    }\n\n    get protocol(): string {\n        return this._protocol;\n    }\n\n    get negotiated(): boolean {\n        return this._negotiated;\n    }\n\n    get readyState(): string {\n        return this._readyState;\n    }\n\n    send(data: string): void;\n    send(data: ArrayBuffer): void;\n    send(data: ArrayBufferView): void;\n    send(data: string | ArrayBuffer | ArrayBufferView): void {\n        if (typeof data === 'string') {\n            WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, data, 'text');\n\n            return;\n        }\n\n        // Safely convert the buffer object to an Uint8Array for base64-encoding\n        if (ArrayBuffer.isView(data)) {\n            data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        } else if (data instanceof ArrayBuffer) {\n            data = new Uint8Array(data);\n        } else {\n            throw new TypeError('Data must be either string, ArrayBuffer, or ArrayBufferView');\n        }\n\n        const base64data = base64.fromByteArray(data as Uint8Array);\n\n        WebRTCModule.dataChannelSend(this._peerConnectionId, this._reactTag, base64data, 'binary');\n    }\n\n    close(): void {\n        if (this._readyState === 'closing' || this._readyState === 'closed') {\n            return;\n        }\n\n        WebRTCModule.dataChannelClose(this._peerConnectionId, this._reactTag);\n    }\n\n    _registerEvents(): void {\n        addListener(this, 'dataChannelStateChanged', (ev: any) => {\n            if (ev.reactTag !== this._reactTag) {\n                return;\n            }\n\n            this._readyState = ev.state;\n\n            if (this._id === null && ev.id !== -1) {\n                this._id = ev.id;\n            }\n\n            if (this._readyState === 'open') {\n                this.dispatchEvent(new RTCDataChannelEvent('open', { channel: this }));\n            } else if (this._readyState === 'closing') {\n                this.dispatchEvent(new RTCDataChannelEvent('closing', { channel: this }));\n            } else if (this._readyState === 'closed') {\n                this.dispatchEvent(new RTCDataChannelEvent('close', { channel: this }));\n\n                // This DataChannel is done, clean up event handlers.\n                removeListener(this);\n\n                WebRTCModule.dataChannelDispose(this._peerConnectionId, this._reactTag);\n            }\n        });\n\n        addListener(this, 'dataChannelReceiveMessage', (ev: any) => {\n            if (ev.reactTag !== this._reactTag) {\n                return;\n            }\n\n            let data = ev.data;\n\n            if (ev.type === 'binary') {\n                data = base64.toByteArray(ev.data).buffer;\n            }\n\n            this.dispatchEvent(new MessageEvent('message', { data }));\n        });\n\n        addListener(this, 'dataChannelDidChangeBufferedAmount', (ev: any) => {\n            if (ev.reactTag !== this._reactTag) {\n                return;\n            }\n\n            this._bufferedAmount = ev.bufferedAmount;\n\n            if (this._bufferedAmount < this.bufferedAmountLowThreshold) {\n                this.dispatchEvent(new RTCDataChannelEvent('bufferedamountlow', { channel: this }));\n            }\n        });\n    }\n}\n\n/**\n * Define the `onxxx` event handlers.\n */\nconst proto = RTCDataChannel.prototype;\n\ndefineEventAttribute(proto, 'bufferedamountlow');\ndefineEventAttribute(proto, 'close');\ndefineEventAttribute(proto, 'closing');\ndefineEventAttribute(proto, 'error');\ndefineEventAttribute(proto, 'message');\ndefineEventAttribute(proto, 'open');\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}